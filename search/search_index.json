{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyBuenColors","text":"<p>A pythonic port of the BuenColors R package for convenient scientific color palettes and matplotlib styles.</p> <p>Color palettes are a direct port from the R package, with many based on the wesanderson R package.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install buencolors\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#using-the-pretty-plot-style","title":"Using the Pretty Plot Style","text":"<p>The easiest way to improve your matplotlib plots is to use the included <code>pretty-plot</code> style:</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Apply the pretty-plot style\nplt.style.use('pretty-plot')\n\n# Create a beautiful plot\nx = np.linspace(0, 10, 100)\nplt.plot(x, np.sin(x), label='sin(x)')\nplt.plot(x, np.cos(x), label='cos(x)')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.show()\n</code></pre> <p>Before (default):</p> <p></p> <p>After (pretty-plot):</p> <p></p>"},{"location":"#using-color-palettes","title":"Using Color Palettes","text":"<p>BuenColors automatically registers all palettes as matplotlib colormaps:</p> <pre><code>import buencolors as bc\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# List available palettes\nbc.list_palettes()\n\n# Palettes are available directly as colormaps\nplt.style.use('pretty-plot')\ndata = np.random.randn(100, 100)\nplt.imshow(data, cmap='Zissou')\nplt.colorbar()\nplt.show()\n\n# Or use get_palette() to extract individual colors\ncolors = bc.get_palette('Zissou')\nfor i, color in enumerate(colors):\n    plt.plot([0, 1], [i, i], color=color, linewidth=10)\nplt.show()\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#helper-functions","title":"Helper Functions","text":"<p>BuenColors provides several utility functions to make your plots publication-ready:</p>"},{"location":"#eject-legend","title":"Eject Legend","text":"<p>Move legends outside the plot area to avoid obscuring data:</p> <pre><code>import matplotlib as plt\nimport buencolors as bc\n\n# Your plot code here\nplt.plot(x, y1, label='Dataset 1')\nplt.plot(x, y2, label='Dataset 2')\n\n# Eject the legend to the right\nbc.eject_legend()\n</code></pre> <p></p>"},{"location":"#rotate-x-tick-labels","title":"Rotate X-Tick Labels","text":"<p>Automatically rotate discrete x-tick labels for better readability:</p> <pre><code>bc.rotate_discrete_xticks()\n</code></pre> <p></p>"},{"location":"#grab-legend","title":"Grab Legend","text":"<p>Extract a legend to a separate figure for independent saving or publication:</p> <pre><code># Create a plot with legend\nplt.plot(x, y1, label='Dataset 1')\nplt.plot(x, y2, label='Dataset 2')\nplt.legend()\n\n# Extract legend to separate figure (removes from original by default)\nlegend_fig = bc.grab_legend()\nlegend_fig.savefig('legend.pdf', bbox_inches='tight')\nplt.savefig('plot.pdf')  # Plot saved without legend\n\n# Or keep legend on original plot\nlegend_fig = bc.grab_legend(remove=False)\nlegend_fig.savefig('legend_copy.pdf', bbox_inches='tight')\nplt.show()  # Original plot still has legend\n</code></pre> <p></p>"},{"location":"#color-by-density","title":"Color by Density","text":"<p>Color scatter plot points by their density:</p> <pre><code>x = np.random.randn(1000)\ny = np.random.randn(1000)\ndensity = bc.get_density(x, y)\n\nplt.scatter(x, y, c=density, cmap='viridis', s=5)\nplt.colorbar(label='Density')\n</code></pre> <p></p>"},{"location":"#shuffle-plot-order","title":"Shuffle Plot Order","text":"<p>Randomize the order of plot elements to avoid overplotting bias:</p> <pre><code>x_shuffled, y_shuffled, colors_shuffled = bc.shuffle(x, y, colors)\nplt.scatter(x_shuffled, y_shuffled, c=colors_shuffled)\n</code></pre> <p></p>"},{"location":"#number-to-color","title":"Number to Color","text":"<p>Map numerical values to colors from a palette:</p> <pre><code>values = [1, 2, 3, 4, 5]\ncolors = bc.number_to_color(values, palette='Zissou')\n</code></pre> <p></p>"},{"location":"#single-cell-analysis","title":"Single-Cell Analysis","text":"<p>BuenColors provides specialized functions for single-cell analysis visualization, designed to work seamlessly with Scanpy and AnnData objects.</p>"},{"location":"#installation-for-single-cell-features","title":"Installation for Single-Cell Features","text":"<p>To use the single-cell features, install with scanpy and anndata:</p> <pre><code>pip install buencolors scanpy anndata\n</code></pre>"},{"location":"#clean-umap-visualization","title":"Clean UMAP Visualization","text":"<p>The <code>clean_umap()</code> function creates publication-ready UMAP plots with minimal decorations:</p> <pre><code>import scanpy as sc\nimport buencolors as bc\nimport matplotlib.pyplot as plt\n\n# Load example dataset\nadata = sc.datasets.pbmc3k_processed()\n\n# Create a clean UMAP colored by cell type\nwith plt.style.context('pretty-plot'):\n    bc.clean_umap(adata, color='louvain', palette='lawhoops')\n</code></pre> <p>Features of <code>clean_umap()</code>:</p> <ul> <li> <p>Minimal decorations: No borders, ticks, or frame</p> </li> <li> <p>Custom L-shaped axis indicators: Small arrows showing UMAP dimensions</p> </li> <li> <p>Auto-ejected legend: Automatically positioned to the right to avoid obscuring data</p> </li> <li> <p>Shuffled cells: Randomizes plotting order to avoid non-random ordering artifacts</p> </li> </ul> <p></p>"},{"location":"#examples","title":"Examples","text":"<p>For detailed examples and interactive notebooks, see the documentation or the docs/examples directory.</p>"},{"location":"#available-palettes","title":"Available Palettes","text":""},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#credits","title":"Credits","text":"<ul> <li>Original BuenColors R package</li> <li>Wes Anderson palettes inspired by wesanderson</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>This page contains the complete API documentation for PyBuenColors, automatically generated from the source code docstrings.</p>"},{"location":"reference/#buencolors","title":"<code>buencolors</code>","text":""},{"location":"reference/#buencolors-functions","title":"Functions","text":""},{"location":"reference/#buencolors.get_palette","title":"<code>get_palette(name, n=None, as_hex=True, reverse=False)</code>","text":"<p>Get colors from a BuenColors palette.</p> <p>This is the pythonic equivalent of R's jdb_palette function, providing flexible access to palette colors for discrete categorical data or interpolated continuous colors.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the palette. Must be a valid BuenColors palette name.</p> required <code>n</code> <code>int, list[int], or None</code> <p>Number of colors to return, specific indices to extract, or None for all colors. - If None: returns all colors from the palette - If int: returns first n colors (discrete) or interpolates n colors if n &gt; palette length - If list: returns colors at those specific indices (0-based, like R's c(1,3) but 0-indexed)</p> <code>None</code> <code>as_hex</code> <code>bool</code> <p>If True, return hex color strings. If False, return RGB(A) arrays. Default is True.</p> <code>True</code> <code>reverse</code> <code>bool</code> <p>If True, reverse the color order. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str] or ndarray</code> <p>If as_hex is True: list of hex color strings (e.g., ['#FF0000', '#00FF00']) If as_hex is False: numpy array of RGB(A) values with shape (n, 3) or (n, 4)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If palette name is not found or if discrete mode is requested with n &gt; palette length.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Get all colors from a palette\n&gt;&gt;&gt; colors = get_palette(\"Cavalcanti\")\n&gt;&gt;&gt; print(colors)\n['#D8B70A', '#02401B', '#A2A475', '#81A88D', '#972D15']\n</code></pre> <pre><code>&gt;&gt;&gt; # Get first 3 colors\n&gt;&gt;&gt; colors = get_palette(\"Cavalcanti\", 3)\n&gt;&gt;&gt; print(colors)\n['#D8B70A', '#02401B', '#A2A475']\n</code></pre> <pre><code>&gt;&gt;&gt; # Get specific color indices (like R's c(0, 2, 4) in 0-based indexing)\n&gt;&gt;&gt; colors = get_palette(\"Cavalcanti\", [0, 2, 4])\n&gt;&gt;&gt; print(colors)\n['#D8B70A', '#A2A475', '#972D15']\n</code></pre> <pre><code>&gt;&gt;&gt; # Interpolate more colors than palette has\n&gt;&gt;&gt; colors = get_palette(\"Zissou\", 21)\n&gt;&gt;&gt; len(colors)\n21\n</code></pre> <pre><code>&gt;&gt;&gt; # Get colors as RGB arrays\n&gt;&gt;&gt; colors_rgb = get_palette(\"berry\", as_hex=False)\n&gt;&gt;&gt; colors_rgb.shape\n(2, 4)\n</code></pre> <pre><code>&gt;&gt;&gt; # Reverse the palette\n&gt;&gt;&gt; colors = get_palette(\"solar_flare\", reverse=True)\n</code></pre> Notes <p>Unlike the R version which strictly differentiates between discrete and continuous modes, this function automatically interpolates when n &gt; palette length, providing smoother gradients. For strict discrete behavior, ensure n &lt;= len(palette).</p>"},{"location":"reference/#buencolors.display_palette","title":"<code>display_palette(name, n=None, figsize=(8, 0.5), show_name=True)</code>","text":"<p>Display a BuenColors palette visually.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the palette to display</p> required <code>n</code> <code>int</code> <p>Number of colors to show. If None, shows all colors from the palette.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size as (width, height). Default is (8, 0.5).</p> <code>(8, 0.5)</code> <code>show_name</code> <code>bool</code> <p>If True, display the palette name above the colors. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The matplotlib figure object containing the palette display.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Display a full palette\n&gt;&gt;&gt; fig = display_palette(\"solar_flare\")\n&gt;&gt;&gt; plt.show()\n</code></pre> <pre><code>&gt;&gt;&gt; # Display only first 5 colors\n&gt;&gt;&gt; fig = display_palette(\"Zissou\", 5)\n&gt;&gt;&gt; plt.show()\n</code></pre> <pre><code>&gt;&gt;&gt; # Display interpolated palette\n&gt;&gt;&gt; fig = display_palette(\"berry\", 21)\n&gt;&gt;&gt; plt.show()\n</code></pre> <pre><code>&gt;&gt;&gt; # Larger figure for presentation\n&gt;&gt;&gt; fig = display_palette(\"brewer_spectra\", figsize=(12, 1))\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"reference/#buencolors.list_palettes","title":"<code>list_palettes(pattern=None, categories=False)</code>","text":"<p>List available BuenColors palettes.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>If provided, only return palettes whose names contain this substring (case-insensitive).</p> <code>None</code> <code>categories</code> <code>bool</code> <p>If True, return palettes grouped by category. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str] or dict</code> <p>If categories is False: sorted list of palette names If categories is True: dictionary mapping categories to palette names</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # List all palettes\n&gt;&gt;&gt; palettes = list_palettes()\n&gt;&gt;&gt; len(palettes)\n117\n</code></pre> <pre><code>&gt;&gt;&gt; # Find flame palettes\n&gt;&gt;&gt; flame_palettes = list_palettes(\"flame\")\n&gt;&gt;&gt; print(flame_palettes)\n['flame_artic', 'flame_blind', 'flame_flame', ...]\n</code></pre> <pre><code>&gt;&gt;&gt; # List by category\n&gt;&gt;&gt; by_category = list_palettes(categories=True)\n&gt;&gt;&gt; print(by_category.keys())\ndict_keys(['wesanderson', 'special', 'jdb', 'brewer', ...])\n</code></pre>"},{"location":"reference/#buencolors.get_registered_cmaps","title":"<code>get_registered_cmaps(include_reversed=False)</code>","text":"<p>Get list of all registered BuenColors colormap names.</p> <p>Parameters:</p> Name Type Description Default <code>include_reversed</code> <code>bool</code> <p>If True, include reversed variants (ending in _r). Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Sorted list of registered colormap names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Get all normal palettes\n&gt;&gt;&gt; cmaps = get_registered_cmaps()\n</code></pre> <pre><code>&gt;&gt;&gt; # Include reversed variants\n&gt;&gt;&gt; all_cmaps = get_registered_cmaps(include_reversed=True)\n</code></pre>"},{"location":"reference/#buencolors.eject_legend","title":"<code>eject_legend(ax=None)</code>","text":"<p>Eject the legend from the plot area to the right side of the axes.</p> <p>This is useful for creating publication-quality plots where the legend should not overlap with the data.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to modify. If None, uses the current axes.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a plot with multiple lines\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; plt.plot(x, np.sin(x), label='sin(x)')\n&gt;&gt;&gt; plt.plot(x, np.cos(x), label='cos(x)')\n&gt;&gt;&gt; plt.plot(x, np.sin(x) * np.cos(x), label='sin(x)cos(x)')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Eject legend to the right\n&gt;&gt;&gt; buencolors.eject_legend()\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or use with a specific axes\n&gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n&gt;&gt;&gt; ax1.plot(x, np.sin(x), label='sin(x)')\n&gt;&gt;&gt; ax1.plot(x, np.cos(x), label='cos(x)')\n&gt;&gt;&gt; ax2.plot(x, x**2, label='x\u00b2')\n&gt;&gt;&gt; ax2.plot(x, x**3, label='x\u00b3')\n&gt;&gt;&gt;\n&gt;&gt;&gt; buencolors.eject_legend(ax1)\n&gt;&gt;&gt; buencolors.eject_legend(ax2)\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"reference/#buencolors.rotate_discrete_xticks","title":"<code>rotate_discrete_xticks(ax=None, rotation=45)</code>","text":"<p>Rotate the x-tick labels for discrete axes with proper alignment.</p> <p>This will rotate the x-tick labels and ensure that the ending of the labels are directly under the ticks for better readability.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to modify. If None, uses the current axes.</p> <code>None</code> <code>rotation</code> <code>float</code> <p>The angle of rotation for the x-tick labels. Default is 45 degrees.</p> <code>45</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Bar plot with long category names\n&gt;&gt;&gt; categories = ['First Category', 'Second Category', 'Third Category',\n...               'Fourth Category', 'Fifth Category']\n&gt;&gt;&gt; values = [23, 45, 56, 78, 32]\n&gt;&gt;&gt;\n&gt;&gt;&gt; plt.bar(categories, values)\n&gt;&gt;&gt; buencolors.rotate_discrete_xticks\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom rotation angle\n&gt;&gt;&gt; plt.bar(categories, values)\n&gt;&gt;&gt; buencolors.rotate_discrete_xticks(rotation=60)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use with specific axes\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; ax.bar(categories, values)\n&gt;&gt;&gt; buencolors.rotate_discrete_xticks(ax, rotation=30)\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"reference/#buencolors.grab_legend","title":"<code>grab_legend(ax=None, remove=True)</code>","text":"<p>Grab the legend from the axes and return it in a new figure for external saving or modification.</p> <p>This is useful for creating separate legend files for publications or presentations, or for combining legends from multiple plots.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to grab the legend from. If None, uses the current axes.</p> <code>None</code> <code>remove</code> <code>bool</code> <p>If True (default), remove the legend from the original axes after extraction. If False, keep the legend on the original axes.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A new figure containing only the legend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a plot and extract legend (removing it from original)\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; plt.plot(x, np.sin(x), label='sin(x)', color='blue')\n&gt;&gt;&gt; plt.plot(x, np.cos(x), label='cos(x)', color='red')\n&gt;&gt;&gt; plt.plot(x, np.tan(x), label='tan(x)', color='green')\n&gt;&gt;&gt; plt.legend()\n&gt;&gt;&gt; plt.ylim(-2, 2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract and save legend separately (legend removed from plot)\n&gt;&gt;&gt; legend_fig = buencolors.grab_legend()\n&gt;&gt;&gt; legend_fig.savefig('legend.pdf', bbox_inches='tight')\n&gt;&gt;&gt; plt.savefig('plot.pdf')  # Plot saved without legend\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract legend while keeping it on the original axes\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; ax.scatter([1, 2, 3], [1, 4, 9], label='Data A', color='blue')\n&gt;&gt;&gt; ax.scatter([1, 2, 3], [2, 3, 5], label='Data B', color='red')\n&gt;&gt;&gt; ax.legend()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Keep legend on original plot\n&gt;&gt;&gt; legend_fig = buencolors.grab_legend(ax, remove=False)\n&gt;&gt;&gt; legend_fig.savefig('my_legend.png', dpi=300, bbox_inches='tight')\n&gt;&gt;&gt; plt.show()  # Original plot still has legend\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Remove legend from original (default behavior)\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; ax.plot(x, np.exp(x), label='exp(x)')\n&gt;&gt;&gt; ax.legend()\n&gt;&gt;&gt; legend_fig = buencolors.grab_legend(ax, remove=True)\n&gt;&gt;&gt; plt.show()  # Original plot has no legend\n</code></pre>"},{"location":"reference/#buencolors.get_density","title":"<code>get_density(x, y, n=200)</code>","text":"<p>Compute the density of points in a grid.</p> <p>Based on the R implementation. This is useful for coloring scatter plot points by their local density to visualize data concentration.</p> <p>Credit to Kamil Slowikowski See post: http://slowkow.com/notes/ggplot2-color-by-density/</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like</code> <p>X coordinates</p> required <code>y</code> <code>array - like</code> <p>Y coordinates</p> required <code>n</code> <code>int</code> <p>Number of bins to divide grid. Default is 200. Higher values give more detail but are slower.</p> <code>200</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A vector of densities for plotting</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create sample data with varying density\n&gt;&gt;&gt; x = np.concatenate([\n...     np.random.normal(0, 0.1, 10000),\n...     np.random.normal(0, 0.1, 1000)\n... ])\n&gt;&gt;&gt; y = np.concatenate([\n...     np.random.normal(0, 0.1, 10000),\n...     np.random.normal(0.1, 0.2, 1000)\n... ])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute density for each point\n&gt;&gt;&gt; density = buencolors.get_density(x, y)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot with color mapped to density\n&gt;&gt;&gt; plt.scatter(x, y, c=density, cmap='viridis', s=1)\n&gt;&gt;&gt; plt.colorbar(label='Point Density')\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use with a BuenColors palette\n&gt;&gt;&gt; density = buencolors.get_density(x, y, n=300)  # Higher resolution\n&gt;&gt;&gt; plt.scatter(x, y, c=density, cmap='solar_flare', s=1, alpha=0.5)\n&gt;&gt;&gt; plt.colorbar()\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"reference/#buencolors.shuffle","title":"<code>shuffle(x)</code>","text":"<pre><code>shuffle(x: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre><pre><code>shuffle(x: pd.Series) -&gt; pd.Series\n</code></pre><pre><code>shuffle(x: np.ndarray) -&gt; np.ndarray\n</code></pre><pre><code>shuffle(x: ArrayLike) -&gt; list\n</code></pre><pre><code>shuffle(x: list) -&gt; list\n</code></pre><pre><code>shuffle(x: tuple) -&gt; tuple\n</code></pre><pre><code>shuffle(x: anndata.AnnData) -&gt; anndata.AnnData\n</code></pre> <p>Shuffle the order of rows/elements to make plots independent of point ordering.</p> <p>This function accepts various data types and returns a shuffled version while preserving the original type when possible. Useful for preventing visual artifacts caused by data ordering in scatter plots.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array-like, DataFrame, or Series</code> <p>Data to shuffle. Can be a list, tuple, numpy array, pandas DataFrame, or pandas Series.</p> required <p>Returns:</p> Type Description <code>same type as input</code> <p>Shuffled version of the input data. For DataFrames and Series, the index is reset. For numpy arrays, a shuffled copy is returned. For lists, a shuffled list is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Shuffle a DataFrame for plotting\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'x': np.random.randn(1000),\n...     'y': np.random.randn(1000),\n...     'category': np.random.choice(['A', 'B', 'C'], 1000)\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Without shuffling, later categories may cover earlier ones\n&gt;&gt;&gt; df_shuffled = buencolors.shuffle(df)\n&gt;&gt;&gt; colors = {'A': 'red', 'B': 'blue', 'C': 'green'}\n&gt;&gt;&gt; df_shuffled['color'] = df_shuffled['category'].map(colors)\n&gt;&gt;&gt; plt.scatter(df_shuffled['x'], df_shuffled['y'], c=df_shuffled['color'], alpha=0.5)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Shuffle a numpy array\n&gt;&gt;&gt; arr = np.random.randn(100, 2)\n&gt;&gt;&gt; arr_shuffled = buencolors.shuffle(arr)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Shuffle a list\n&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; lst_shuffled = buencolors.shuffle(lst)\n</code></pre> Notes <p>This also supports scanpy AnnData objects by shuffling the obs index when the anndata package is installed.</p>"},{"location":"reference/#buencolors.number_to_color","title":"<code>number_to_color(values, palette, value_range=None, n_bins=None, return_rgb=False)</code>","text":"<p>Map numeric values to colors from a palette.</p> <p>This is the pythonic equivalent of R's numberToColorVec function, with support for both continuous and discrete (binned) color mapping.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>array - like</code> <p>Numeric values to map to colors</p> required <code>palette</code> <code>str or Colormap</code> <p>Name of a registered colormap or a Colormap object. Can be any matplotlib colormap or a BuenColors palette name.</p> required <code>value_range</code> <code>tuple[float, float]</code> <p>(min, max) values to clip and normalize. If None, uses the min/max of values. Values outside this range will be clipped to the range bounds.</p> <code>None</code> <code>n_bins</code> <code>int</code> <p>Number of discrete color bins to use. If None (default), uses continuous mapping. If specified, values will be binned into n_bins discrete colors, similar to the R implementation (which uses 100 bins). Common values: 100, 256.</p> <code>None</code> <code>return_rgb</code> <code>bool</code> <p>If True, return RGB arrays instead of hex strings. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str] or ndarray</code> <p>If return_rgb is False: list of hex color strings (e.g., '#FF5733') If return_rgb is True: numpy array of shape (n, 4) with RGBA values in [0, 1]</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Basic usage: map values to colors\n&gt;&gt;&gt; values = np.random.randn(1000) ** 2\n&gt;&gt;&gt; colors = buencolors.number_to_color(values, \"viridis\")\n&gt;&gt;&gt; plt.scatter(np.arange(len(values)), values, c=colors)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use a BuenColors palette\n&gt;&gt;&gt; colors = buencolors.number_to_color(values, \"solar_flare\")\n&gt;&gt;&gt; plt.scatter(np.arange(len(values)), values, c=colors)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Discrete binned colors (like R implementation)\n&gt;&gt;&gt; colors = buencolors.number_to_color(values, \"brewer_spectra\", n_bins=100)\n&gt;&gt;&gt; plt.scatter(np.arange(len(values)), values, c=colors, s=20)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With custom value range (capping)\n&gt;&gt;&gt; colors = buencolors.number_to_color(values, \"plasma\", value_range=(0, 2))\n&gt;&gt;&gt; plt.scatter(np.arange(len(values)), values, c=colors)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get RGB arrays instead of hex\n&gt;&gt;&gt; colors_rgb = buencolors.number_to_color(values[:10], \"magma\", return_rgb=True)\n&gt;&gt;&gt; print(colors_rgb.shape)  # (10, 4) RGBA values\n(10, 4)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Combined with shuffle for better visualization\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'x': np.random.randn(500),\n...     'y': np.random.randn(500),\n...     'value': np.random.randn(500) ** 2\n... })\n&gt;&gt;&gt; df['color'] = buencolors.number_to_color(df['value'], \"flame_flame\", n_bins=50)\n&gt;&gt;&gt; df = buencolors.shuffle(df)\n&gt;&gt;&gt; plt.scatter(df['x'], df['y'], c=df['color'], s=30, alpha=0.6)\n&gt;&gt;&gt; plt.show()\n</code></pre> Notes <p>The default behavior (n_bins=None) uses continuous color mapping for smoother gradients. Set n_bins=100 to match the R implementation's discrete binning.</p> <p>For more advanced discrete colormapping, consider using matplotlib's BoundaryNorm.</p>"},{"location":"reference/#buencolors.clean_umap","title":"<code>clean_umap(adata, color, ax=None, axis_len=0.2, thickness=3.0, **kwargs)</code>","text":"<p>Plot a clean UMAP with minimal decorations and custom axis indicators.</p> <p>Plots a Scanpy UMAP with no borders/ticks, but adds a small 'L' shaped axis indicator in the bottom left corner with arrowheads. The legend is ejected to the right side of the plot. Cells are automatically shuffled to avoid non-random ordering artifacts.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>AnnData object containing the UMAP coordinates</p> required <code>color</code> <code>str</code> <p>Column in adata.obs or gene name to color cells by</p> required <code>ax</code> <code>Axes</code> <p>Existing matplotlib axis. If None, creates a new axis.</p> <code>None</code> <code>axis_len</code> <code>float</code> <p>Length of the custom axis arrows in relative axes coordinates (0-1). Default is 0.2.</p> <code>0.2</code> <code>thickness</code> <code>float</code> <p>Line width of the custom axes. Default is 3.0.</p> <code>3.0</code> <code>**kwargs</code> <p>Additional keyword arguments passed to sc.pl.umap</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib axes containing the UMAP plot</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import scanpy as sc\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load example dataset\n&gt;&gt;&gt; adata = sc.datasets.pbmc3k_processed()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot clean UMAP colored by cell type\n&gt;&gt;&gt; buencolors.clean_umap(adata, color='louvain')\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Customize axis length and thickness\n&gt;&gt;&gt; buencolors.clean_umap(adata, color='louvain', axis_len=0.3, thickness=4.0)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use with existing axis and pass additional arguments\n&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 6))\n&gt;&gt;&gt; buencolors.clean_umap(adata, color='CST3', ax=ax, cmap='viridis')\n&gt;&gt;&gt; plt.tight_layout()\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Interactive Jupyter notebooks demonstrating the features and capabilities of PyBuenColors.</p>"},{"location":"examples/#available-notebooks","title":"Available Notebooks","text":""},{"location":"examples/#helper-functions","title":"Helper Functions","text":"<p>Comprehensive demonstration of utility functions for creating publication-ready plots:</p> <ul> <li><code>eject_legend()</code> - Move legends outside the plot area to avoid obscuring data</li> <li><code>rotate_discrete_xticks()</code> - Rotate x-axis labels for better readability</li> <li><code>grab_legend()</code> - Extract legends to separate figures for independent saving</li> <li><code>get_density()</code> - Compute point density for colored scatter plots</li> <li><code>shuffle()</code> - Randomize data order to prevent plotting artifacts</li> <li><code>number_to_color()</code> - Map numerical values to colors from any palette</li> </ul>"},{"location":"examples/#color-palettes","title":"Color Palettes","text":"<p>Explore the 117+ scientific color palettes available in PyBuenColors:</p> <ul> <li><code>list_palettes()</code> - Browse and filter available palettes</li> <li><code>display_palette()</code> - Visualize individual palettes</li> <li><code>get_palette()</code> - Extract colors for use in plots</li> <li>Wes Anderson-inspired palettes</li> <li>Scientific visualization color schemes</li> <li>Sequential and diverging gradients</li> </ul>"},{"location":"examples/#single-cell-analysis","title":"Single-Cell Analysis","text":"<p>Specialized functions for single-cell RNA-seq visualization with Scanpy integration:</p> <ul> <li><code>clean_umap()</code> - Create publication-quality UMAP plots with minimal decorations</li> <li>Gene expression visualization with custom colormaps</li> <li>L-shaped axis indicators for dimensional reduction plots</li> <li>Multi-panel figures for publications</li> <li>Integration with Scanpy workflows</li> </ul> <p>Optional Dependencies</p> <p>The single-cell analysis notebook requires <code>scanpy</code> and <code>anndata</code>: <pre><code>pip install buencolors scanpy anndata\n</code></pre></p>"},{"location":"examples/#running-locally","title":"Running Locally","text":"<p>To run these notebooks on your own machine:</p> <pre><code># Install Jupyter\npip install jupyter\n\n# Clone the repository\ngit clone https://github.com/austinv11/PyBuenColors.git\ncd PyBuenColors/docs/examples\n\n# Launch Jupyter\njupyter notebook\n</code></pre> <p>All notebooks are designed to run independently and include detailed explanations of each feature.</p>"},{"location":"examples/helpers_demo/","title":"BuenColors Helper Functions Demo","text":"<pre>Original plot still has legend: True\n</pre> <pre>\nShuffle also works with:\n- NumPy arrays: &lt;class 'numpy.ndarray'&gt;\n- Lists: &lt;class 'list'&gt;\n- Tuples: &lt;class 'tuple'&gt;\n</pre>"},{"location":"examples/helpers_demo/#buencolors-helper-functions-demo","title":"BuenColors Helper Functions Demo\u00b6","text":"<p>This notebook demonstrates all the helper functions available in the BuenColors package.</p>"},{"location":"examples/helpers_demo/#installation","title":"Installation\u00b6","text":"<pre>pip install buencolors\n</pre>"},{"location":"examples/helpers_demo/#1-eject_legend-move-legend-outside-plot","title":"1. <code>eject_legend()</code> - Move Legend Outside Plot\u00b6","text":"<p>Moves the legend to the right side of the plot, preventing it from obscuring data.</p>"},{"location":"examples/helpers_demo/#2-rotate_discrete_xticks-rotate-x-axis-labels","title":"2. <code>rotate_discrete_xticks()</code> - Rotate X-Axis Labels\u00b6","text":"<p>Rotates x-axis labels for better readability with long category names.</p>"},{"location":"examples/helpers_demo/#3-grab_legend-extract-legend-to-separate-figure","title":"3. <code>grab_legend()</code> - Extract Legend to Separate Figure\u00b6","text":"<p>The <code>grab_legend()</code> function extracts a legend to a separate figure, useful for creating independent legend files for publications.</p> <p>New in this version: The <code>remove</code> parameter controls whether the legend is removed from the original axes:</p> <ul> <li><code>remove=True</code> (default): Legend is removed from the original plot</li> <li><code>remove=False</code>: Legend remains on the original plot</li> </ul>"},{"location":"examples/helpers_demo/#4-get_density-compute-point-density","title":"4. <code>get_density()</code> - Compute Point Density\u00b6","text":"<p>Computes the local density of points for coloring scatter plots by concentration.</p>"},{"location":"examples/helpers_demo/#5-shuffle-randomize-data-order","title":"5. <code>shuffle()</code> - Randomize Data Order\u00b6","text":"<p>Shuffles various data types (DataFrames, arrays, lists) to prevent plotting artifacts from data ordering.</p>"},{"location":"examples/helpers_demo/#6-number_to_color-map-values-to-colors","title":"6. <code>number_to_color()</code> - Map Values to Colors\u00b6","text":"<p>Maps numeric values to colors from a palette, supporting both continuous and discrete binning.</p>"},{"location":"examples/helpers_demo/#combined-example-density-shuffle-number-to-color","title":"Combined Example: Density + Shuffle + Number to Color\u00b6","text":"<p>Combining multiple helper functions for a publication-quality visualization.</p>"},{"location":"examples/helpers_demo/#summary","title":"Summary\u00b6","text":"<p>The BuenColors helper functions provide:</p> <ol> <li><code>eject_legend()</code> - Move legends outside plots</li> <li><code>rotate_discrete_xticks()</code> - Rotate axis labels for readability</li> <li><code>grab_legend()</code> - Extract legends to separate figures</li> <li><code>get_density()</code> - Compute point density for scatter plots</li> <li><code>shuffle()</code> - Randomize data to prevent plotting artifacts</li> <li><code>number_to_color()</code> - Map numeric values to colors</li> </ol> <p>These functions work seamlessly together to create publication-quality visualizations!</p>"},{"location":"examples/palettes_demo/","title":"BuenColors Palettes Demo","text":"<pre>Total palettes available: 106\n\nFirst 20 palettes: ['BottleRocket', 'BottleRocket2', 'Cavalcanti', 'Chevalier', 'Darjeeling', 'Darjeeling2', 'FantasticFox', 'GrandBudapest', 'GrandBudapest2', 'Moonrise1', 'Moonrise2', 'Moonrise3', 'Royal1', 'Royal2', 'Rushmore', 'Zissou', 'algae_earth', 'aqua_brick', 'aqua_tan', 'berry']\n</pre> <pre>Flame palettes (10): ['flame_artic', 'flame_blind', 'flame_flame', 'flame_light', 'flame_macaw', 'flame_polar', 'flame_volts', 'flame_watts', 'flame_weird', 'flame_wings']\n\nSolar palettes (6): ['solar_basic', 'solar_blues', 'solar_extra', 'solar_flare', 'solar_glare', 'solar_rojos']\n\nOcean palettes (8): ['ocean_aqua', 'ocean_brick', 'ocean_citrus', 'ocean_earth', 'ocean_green', 'ocean_pink', 'ocean_red', 'ocean_teal']\n</pre> <pre>Palettes by category:\n\nWESANDERSON (16):\n  BottleRocket, BottleRocket2, Cavalcanti, Chevalier, Darjeeling...\n\nSPECIAL (2):\n  corona, lawhoops\n\nSOLAR (11):\n  samba_color, samba_light, samba_night, solar_basic, solar_blues...\n\nFLAME (10):\n  flame_artic, flame_blind, flame_flame, flame_light, flame_macaw...\n\nOCEAN (20):\n  aqua_brick, aqua_tan, blue_cyan, cyan_brick, cyan_green...\n\nCALMA (6):\n  calma_azules, calma_bosque, calma_manudo, calma_marino, calma_morado...\n\nCHINA (7):\n  china_basics, china_dragon, china_novice, china_ranges, china_sunset...\n\nBREWER (13):\n  brewer_blue, brewer_celsius, brewer_fire, brewer_green, brewer_heat...\n\nCOLOR_GRADIENTS (16):\n  algae_earth, berry, citric, citric_yellow, forest...\n\nDARK (4):\n  dark_blue, dark_citrus, dark_violet, dusk_dawn\n\nOTHER (1):\n  citrus\n\n</pre> <pre>Original palette:\n</pre> <pre>\nInterpolated to 21 colors:\n</pre> <pre>Cavalcanti palette: ['#D8B70A', '#02401B', '#A2A475', '#81A88D', '#972D15']\n\nFirst 3 colors: ['#D8B70A', '#02401B', '#A2A475']\n\nColors at indices [0, 2, 4]: ['#D8B70A', '#A2A475', '#972D15']\n\nBerry palette interpolated to 10 colors: ['#7700ff', '#8600f1', '#9500e3', '#a400d5', '#b300c7', '#c300b8', '#d200aa', '#e1009c', '#f0008e', '#ff0080']\n</pre> <pre>Zissou palette as RGB:\n[[0.23137255 0.60392157 0.69803922 1.        ]\n [0.47058824 0.71764706 0.77254902 1.        ]\n [0.92156863 0.8        0.16470588 1.        ]\n [0.88235294 0.68627451 0.         1.        ]\n [0.94901961 0.10196078 0.         1.        ]]\nShape: (5, 4)\n</pre> <pre>Wes Anderson Inspired Palettes:\n\n</pre> <pre>Brewer (ColorBrewer-inspired) Palettes:\n\n</pre> <pre>horizon: Dark to bright gradient\n</pre> <pre>dark_citrus: Black to lime green\n</pre> <pre>dark_violet: Black to magenta\n</pre> <pre>cyan_pink: Cyan to pink gradient\n</pre> <pre>purple_baby: Purple to baby blue\n</pre> <pre>teal_orange: Teal to orange\n</pre> <pre>\n============================================================\nWESANDERSON PALETTES (16 total)\n============================================================\n\n</pre> <pre>\n============================================================\nSPECIAL PALETTES (2 total)\n============================================================\n\n</pre> <pre>\n============================================================\nSOLAR PALETTES (11 total)\n============================================================\n\n</pre> <pre>\n============================================================\nFLAME PALETTES (10 total)\n============================================================\n\n</pre> <pre>\n============================================================\nOCEAN PALETTES (20 total)\n============================================================\n\n</pre> <pre>\n============================================================\nCALMA PALETTES (6 total)\n============================================================\n\n</pre> <pre>\n============================================================\nCHINA PALETTES (7 total)\n============================================================\n\n</pre> <pre>\n============================================================\nBREWER PALETTES (13 total)\n============================================================\n\n</pre> <pre>\n============================================================\nCOLOR_GRADIENTS PALETTES (16 total)\n============================================================\n\n</pre> <pre>\n============================================================\nDARK PALETTES (4 total)\n============================================================\n\n</pre> <pre>\n============================================================\nOTHER PALETTES (1 total)\n============================================================\n\n</pre>"},{"location":"examples/palettes_demo/#buencolors-palettes-demo","title":"BuenColors Palettes Demo\u00b6","text":"<p>This notebook demonstrates all the palette functionality in the BuenColors package.</p> <p>BuenColors includes 117 color palettes inspired by Wes Anderson films, scientific visualization, and custom designs.</p>"},{"location":"examples/palettes_demo/#installation","title":"Installation\u00b6","text":"<pre>pip install buencolors\n</pre>"},{"location":"examples/palettes_demo/#1-list_palettes-browse-available-palettes","title":"1. <code>list_palettes()</code> - Browse Available Palettes\u00b6","text":"<p>Discover all available palettes, with filtering and categorization options.</p>"},{"location":"examples/palettes_demo/#2-display_palette-visualize-palettes","title":"2. <code>display_palette()</code> - Visualize Palettes\u00b6","text":"<p>Display palettes as horizontal color bars.</p>"},{"location":"examples/palettes_demo/#3-get_palette-extract-colors","title":"3. <code>get_palette()</code> - Extract Colors\u00b6","text":"<p>Get colors from palettes for use in your plots.</p>"},{"location":"examples/palettes_demo/#4-using-palettes-with-matplotlib","title":"4. Using Palettes with Matplotlib\u00b6","text":"<p>All BuenColors palettes are automatically registered with matplotlib as colormaps.</p>"},{"location":"examples/palettes_demo/#reversed-palettes","title":"Reversed Palettes\u00b6","text":"<p>All palettes have reversed versions with the <code>_r</code> suffix.</p>"},{"location":"examples/palettes_demo/#5-discrete-color-usage-for-categorical-data","title":"5. Discrete Color Usage for Categorical Data\u00b6","text":"<p>Using palette colors for categorical/discrete data visualization.</p>"},{"location":"examples/palettes_demo/#6-wes-anderson-palettes","title":"6. Wes Anderson Palettes\u00b6","text":"<p>BuenColors includes all palettes from the wesanderson R package.</p>"},{"location":"examples/palettes_demo/#7-scientific-visualization-palettes","title":"7. Scientific Visualization Palettes\u00b6","text":"<p>Palettes designed for scientific data visualization.</p>"},{"location":"examples/palettes_demo/#8-custom-color-gradients","title":"8. Custom Color Gradients\u00b6","text":"<p>Specialized gradients for unique visualization needs.</p>"},{"location":"examples/palettes_demo/#9-gallery-all-palette-categories","title":"9. Gallery: All Palette Categories\u00b6","text":"<p>Browse palettes by category.</p>"},{"location":"examples/palettes_demo/#summary","title":"Summary\u00b6","text":"<p>BuenColors provides comprehensive palette functionality:</p> <ol> <li><code>list_palettes()</code> - Browse and filter 117+ palettes</li> <li><code>display_palette()</code> - Visualize palettes</li> <li><code>get_palette()</code> - Extract colors for use in plots</li> <li>Automatic matplotlib integration - All palettes work as colormaps</li> <li>Reversed variants - All palettes have <code>_r</code> versions</li> <li>Multiple categories - Wes Anderson, scientific, gradients, and more</li> </ol> <p>Perfect for:</p> <ul> <li>Publication-quality figures</li> <li>Scientific visualization</li> <li>Data exploration</li> <li>Categorical data</li> <li>Heatmaps and continuous data</li> </ul> <p>All palettes are pythonic implementations inspired by the R BuenColors package!</p>"},{"location":"examples/single_cell_demo/","title":"BuenColors Single Cell Demo","text":"<pre>\u2713 Scanpy and AnnData are available\n</pre> <pre>Dataset shape: (2638, 1838)\nAvailable observations: ['n_genes', 'percent_mito', 'n_counts', 'louvain']\n\nCell type distribution:\nlouvain\nCD4 T cells          1144\nCD14+ Monocytes       480\nB cells               342\nCD8 T cells           316\nNK cells              154\nFCGR3A+ Monocytes     150\nDendritic cells        37\nMegakaryocytes         15\nName: count, dtype: int64\n</pre> <pre>&lt;Figure size 1000x800 with 0 Axes&gt;</pre> <pre>&lt;Figure size 1000x800 with 0 Axes&gt;</pre> <pre>&lt;Figure size 2500x2000 with 0 Axes&gt;</pre>"},{"location":"examples/single_cell_demo/#buencolors-single-cell-demo","title":"BuenColors Single Cell Demo\u00b6","text":"<p>This notebook demonstrates the single-cell analysis features in BuenColors, designed to work with Scanpy and AnnData objects.</p>"},{"location":"examples/single_cell_demo/#installation","title":"Installation\u00b6","text":"<p>To use the single-cell features, you need to have <code>scanpy</code> and <code>anndata</code> installed:</p> <pre>pip install buencolors scanpy anndata\n</pre>"},{"location":"examples/single_cell_demo/#load-example-dataset","title":"Load Example Dataset\u00b6","text":"<p>We'll use the PBMC3k dataset, a standard example in single-cell analysis that contains ~3000 peripheral blood mononuclear cells.</p>"},{"location":"examples/single_cell_demo/#clean-umap-visualization","title":"Clean UMAP Visualization\u00b6","text":"<p>The <code>clean_umap()</code> function creates beautiful, publication-ready UMAP plots with:</p> <ul> <li>Minimal decorations (no borders, ticks, or frame)</li> <li>Custom L-shaped axis indicators with arrowheads</li> <li>Automatically ejected legend to the right side</li> <li>Shuffled cells to avoid non-random ordering artifacts</li> </ul>"},{"location":"examples/single_cell_demo/#basic-usage-cell-type-coloring","title":"Basic Usage - Cell Type Coloring\u00b6","text":""},{"location":"examples/single_cell_demo/#gene-expression-visualization","title":"Gene Expression Visualization\u00b6","text":"<p>You can also color cells by gene expression levels:</p>"},{"location":"examples/single_cell_demo/#customizing-axis-indicators","title":"Customizing Axis Indicators\u00b6","text":"<p>You can customize the appearance of the axis indicators:</p>"},{"location":"examples/single_cell_demo/#comparison-standard-vs-clean-umap","title":"Comparison: Standard vs Clean UMAP\u00b6","text":"<p>Let's compare the standard Scanpy UMAP with BuenColors' clean version:</p>"},{"location":"examples/single_cell_demo/#using-buencolors-palettes-with-umaps","title":"Using BuenColors Palettes with UMAPs\u00b6","text":"<p>You can combine <code>clean_umap()</code> with BuenColors' beautiful color palettes:</p>"},{"location":"examples/single_cell_demo/#multiple-color-variables","title":"Multiple Color Variables\u00b6","text":"<p>Create a multi-panel figure showing different aspects of your data:</p>"},{"location":"examples/single_cell_demo/#combining-with-pretty-plot-style","title":"Combining with Pretty Plot Style\u00b6","text":"<p>For even better-looking plots, combine <code>clean_umap()</code> with the BuenColors <code>pretty-plot</code> style:</p>"},{"location":"examples/single_cell_demo/#summary","title":"Summary\u00b6","text":"<p>The <code>clean_umap()</code> function provides:</p> <ol> <li>Minimal decorations - Clean, publication-ready plots without unnecessary visual clutter</li> <li>Custom axis indicators - Professional L-shaped axes with arrowheads</li> <li>Auto-ejected legends - Legends placed outside the plot area to avoid obscuring data</li> <li>Cell shuffling - Automatic randomization to prevent ordering artifacts</li> <li>Full customization - Compatible with all Scanpy UMAP parameters</li> </ol>"},{"location":"examples/single_cell_demo/#parameters","title":"Parameters\u00b6","text":"<ul> <li><code>adata</code>: AnnData object containing UMAP coordinates</li> <li><code>color</code>: Column in adata.obs or gene name for coloring</li> <li><code>ax</code>: Optional matplotlib axis (if None, creates new)</li> <li><code>axis_len</code>: Length of axis indicators (default: 0.2)</li> <li><code>thickness</code>: Line width of axis indicators (default: 3.0)</li> <li><code>**kwargs</code>: Additional arguments passed to <code>sc.pl.umap()</code></li> </ul>"},{"location":"examples/single_cell_demo/#compatibility","title":"Compatibility\u00b6","text":"<p>Requires:</p> <ul> <li><code>anndata</code> - for AnnData objects</li> <li><code>scanpy</code> - for UMAP plotting</li> <li><code>matplotlib</code> - for plotting (already a BuenColors dependency)</li> </ul>"},{"location":"reference/buencolors/","title":"buencolors","text":""},{"location":"reference/buencolors/#buencolors","title":"<code>buencolors</code>","text":""},{"location":"reference/buencolors/#buencolors-functions","title":"Functions","text":""},{"location":"reference/buencolors/#buencolors.get_palette","title":"<code>get_palette(name, n=None, as_hex=True, reverse=False)</code>","text":"<p>Get colors from a BuenColors palette.</p> <p>This is the pythonic equivalent of R's jdb_palette function, providing flexible access to palette colors for discrete categorical data or interpolated continuous colors.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the palette. Must be a valid BuenColors palette name.</p> required <code>n</code> <code>int, list[int], or None</code> <p>Number of colors to return, specific indices to extract, or None for all colors. - If None: returns all colors from the palette - If int: returns first n colors (discrete) or interpolates n colors if n &gt; palette length - If list: returns colors at those specific indices (0-based, like R's c(1,3) but 0-indexed)</p> <code>None</code> <code>as_hex</code> <code>bool</code> <p>If True, return hex color strings. If False, return RGB(A) arrays. Default is True.</p> <code>True</code> <code>reverse</code> <code>bool</code> <p>If True, reverse the color order. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str] or ndarray</code> <p>If as_hex is True: list of hex color strings (e.g., ['#FF0000', '#00FF00']) If as_hex is False: numpy array of RGB(A) values with shape (n, 3) or (n, 4)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If palette name is not found or if discrete mode is requested with n &gt; palette length.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Get all colors from a palette\n&gt;&gt;&gt; colors = get_palette(\"Cavalcanti\")\n&gt;&gt;&gt; print(colors)\n['#D8B70A', '#02401B', '#A2A475', '#81A88D', '#972D15']\n</code></pre> <pre><code>&gt;&gt;&gt; # Get first 3 colors\n&gt;&gt;&gt; colors = get_palette(\"Cavalcanti\", 3)\n&gt;&gt;&gt; print(colors)\n['#D8B70A', '#02401B', '#A2A475']\n</code></pre> <pre><code>&gt;&gt;&gt; # Get specific color indices (like R's c(0, 2, 4) in 0-based indexing)\n&gt;&gt;&gt; colors = get_palette(\"Cavalcanti\", [0, 2, 4])\n&gt;&gt;&gt; print(colors)\n['#D8B70A', '#A2A475', '#972D15']\n</code></pre> <pre><code>&gt;&gt;&gt; # Interpolate more colors than palette has\n&gt;&gt;&gt; colors = get_palette(\"Zissou\", 21)\n&gt;&gt;&gt; len(colors)\n21\n</code></pre> <pre><code>&gt;&gt;&gt; # Get colors as RGB arrays\n&gt;&gt;&gt; colors_rgb = get_palette(\"berry\", as_hex=False)\n&gt;&gt;&gt; colors_rgb.shape\n(2, 4)\n</code></pre> <pre><code>&gt;&gt;&gt; # Reverse the palette\n&gt;&gt;&gt; colors = get_palette(\"solar_flare\", reverse=True)\n</code></pre> Notes <p>Unlike the R version which strictly differentiates between discrete and continuous modes, this function automatically interpolates when n &gt; palette length, providing smoother gradients. For strict discrete behavior, ensure n &lt;= len(palette).</p>"},{"location":"reference/buencolors/#buencolors.display_palette","title":"<code>display_palette(name, n=None, figsize=(8, 0.5), show_name=True)</code>","text":"<p>Display a BuenColors palette visually.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the palette to display</p> required <code>n</code> <code>int</code> <p>Number of colors to show. If None, shows all colors from the palette.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size as (width, height). Default is (8, 0.5).</p> <code>(8, 0.5)</code> <code>show_name</code> <code>bool</code> <p>If True, display the palette name above the colors. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The matplotlib figure object containing the palette display.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Display a full palette\n&gt;&gt;&gt; fig = display_palette(\"solar_flare\")\n&gt;&gt;&gt; plt.show()\n</code></pre> <pre><code>&gt;&gt;&gt; # Display only first 5 colors\n&gt;&gt;&gt; fig = display_palette(\"Zissou\", 5)\n&gt;&gt;&gt; plt.show()\n</code></pre> <pre><code>&gt;&gt;&gt; # Display interpolated palette\n&gt;&gt;&gt; fig = display_palette(\"berry\", 21)\n&gt;&gt;&gt; plt.show()\n</code></pre> <pre><code>&gt;&gt;&gt; # Larger figure for presentation\n&gt;&gt;&gt; fig = display_palette(\"brewer_spectra\", figsize=(12, 1))\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"reference/buencolors/#buencolors.list_palettes","title":"<code>list_palettes(pattern=None, categories=False)</code>","text":"<p>List available BuenColors palettes.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>If provided, only return palettes whose names contain this substring (case-insensitive).</p> <code>None</code> <code>categories</code> <code>bool</code> <p>If True, return palettes grouped by category. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str] or dict</code> <p>If categories is False: sorted list of palette names If categories is True: dictionary mapping categories to palette names</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # List all palettes\n&gt;&gt;&gt; palettes = list_palettes()\n&gt;&gt;&gt; len(palettes)\n117\n</code></pre> <pre><code>&gt;&gt;&gt; # Find flame palettes\n&gt;&gt;&gt; flame_palettes = list_palettes(\"flame\")\n&gt;&gt;&gt; print(flame_palettes)\n['flame_artic', 'flame_blind', 'flame_flame', ...]\n</code></pre> <pre><code>&gt;&gt;&gt; # List by category\n&gt;&gt;&gt; by_category = list_palettes(categories=True)\n&gt;&gt;&gt; print(by_category.keys())\ndict_keys(['wesanderson', 'special', 'jdb', 'brewer', ...])\n</code></pre>"},{"location":"reference/buencolors/#buencolors.get_registered_cmaps","title":"<code>get_registered_cmaps(include_reversed=False)</code>","text":"<p>Get list of all registered BuenColors colormap names.</p> <p>Parameters:</p> Name Type Description Default <code>include_reversed</code> <code>bool</code> <p>If True, include reversed variants (ending in _r). Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Sorted list of registered colormap names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Get all normal palettes\n&gt;&gt;&gt; cmaps = get_registered_cmaps()\n</code></pre> <pre><code>&gt;&gt;&gt; # Include reversed variants\n&gt;&gt;&gt; all_cmaps = get_registered_cmaps(include_reversed=True)\n</code></pre>"},{"location":"reference/buencolors/#buencolors.eject_legend","title":"<code>eject_legend(ax=None)</code>","text":"<p>Eject the legend from the plot area to the right side of the axes.</p> <p>This is useful for creating publication-quality plots where the legend should not overlap with the data.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to modify. If None, uses the current axes.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a plot with multiple lines\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; plt.plot(x, np.sin(x), label='sin(x)')\n&gt;&gt;&gt; plt.plot(x, np.cos(x), label='cos(x)')\n&gt;&gt;&gt; plt.plot(x, np.sin(x) * np.cos(x), label='sin(x)cos(x)')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Eject legend to the right\n&gt;&gt;&gt; buencolors.eject_legend()\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or use with a specific axes\n&gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n&gt;&gt;&gt; ax1.plot(x, np.sin(x), label='sin(x)')\n&gt;&gt;&gt; ax1.plot(x, np.cos(x), label='cos(x)')\n&gt;&gt;&gt; ax2.plot(x, x**2, label='x\u00b2')\n&gt;&gt;&gt; ax2.plot(x, x**3, label='x\u00b3')\n&gt;&gt;&gt;\n&gt;&gt;&gt; buencolors.eject_legend(ax1)\n&gt;&gt;&gt; buencolors.eject_legend(ax2)\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"reference/buencolors/#buencolors.rotate_discrete_xticks","title":"<code>rotate_discrete_xticks(ax=None, rotation=45)</code>","text":"<p>Rotate the x-tick labels for discrete axes with proper alignment.</p> <p>This will rotate the x-tick labels and ensure that the ending of the labels are directly under the ticks for better readability.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to modify. If None, uses the current axes.</p> <code>None</code> <code>rotation</code> <code>float</code> <p>The angle of rotation for the x-tick labels. Default is 45 degrees.</p> <code>45</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Bar plot with long category names\n&gt;&gt;&gt; categories = ['First Category', 'Second Category', 'Third Category',\n...               'Fourth Category', 'Fifth Category']\n&gt;&gt;&gt; values = [23, 45, 56, 78, 32]\n&gt;&gt;&gt;\n&gt;&gt;&gt; plt.bar(categories, values)\n&gt;&gt;&gt; buencolors.rotate_discrete_xticks\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom rotation angle\n&gt;&gt;&gt; plt.bar(categories, values)\n&gt;&gt;&gt; buencolors.rotate_discrete_xticks(rotation=60)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use with specific axes\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; ax.bar(categories, values)\n&gt;&gt;&gt; buencolors.rotate_discrete_xticks(ax, rotation=30)\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"reference/buencolors/#buencolors.grab_legend","title":"<code>grab_legend(ax=None, remove=True)</code>","text":"<p>Grab the legend from the axes and return it in a new figure for external saving or modification.</p> <p>This is useful for creating separate legend files for publications or presentations, or for combining legends from multiple plots.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to grab the legend from. If None, uses the current axes.</p> <code>None</code> <code>remove</code> <code>bool</code> <p>If True (default), remove the legend from the original axes after extraction. If False, keep the legend on the original axes.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A new figure containing only the legend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a plot and extract legend (removing it from original)\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; plt.plot(x, np.sin(x), label='sin(x)', color='blue')\n&gt;&gt;&gt; plt.plot(x, np.cos(x), label='cos(x)', color='red')\n&gt;&gt;&gt; plt.plot(x, np.tan(x), label='tan(x)', color='green')\n&gt;&gt;&gt; plt.legend()\n&gt;&gt;&gt; plt.ylim(-2, 2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract and save legend separately (legend removed from plot)\n&gt;&gt;&gt; legend_fig = buencolors.grab_legend()\n&gt;&gt;&gt; legend_fig.savefig('legend.pdf', bbox_inches='tight')\n&gt;&gt;&gt; plt.savefig('plot.pdf')  # Plot saved without legend\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract legend while keeping it on the original axes\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; ax.scatter([1, 2, 3], [1, 4, 9], label='Data A', color='blue')\n&gt;&gt;&gt; ax.scatter([1, 2, 3], [2, 3, 5], label='Data B', color='red')\n&gt;&gt;&gt; ax.legend()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Keep legend on original plot\n&gt;&gt;&gt; legend_fig = buencolors.grab_legend(ax, remove=False)\n&gt;&gt;&gt; legend_fig.savefig('my_legend.png', dpi=300, bbox_inches='tight')\n&gt;&gt;&gt; plt.show()  # Original plot still has legend\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Remove legend from original (default behavior)\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; ax.plot(x, np.exp(x), label='exp(x)')\n&gt;&gt;&gt; ax.legend()\n&gt;&gt;&gt; legend_fig = buencolors.grab_legend(ax, remove=True)\n&gt;&gt;&gt; plt.show()  # Original plot has no legend\n</code></pre>"},{"location":"reference/buencolors/#buencolors.get_density","title":"<code>get_density(x, y, n=200)</code>","text":"<p>Compute the density of points in a grid.</p> <p>Based on the R implementation. This is useful for coloring scatter plot points by their local density to visualize data concentration.</p> <p>Credit to Kamil Slowikowski See post: http://slowkow.com/notes/ggplot2-color-by-density/</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like</code> <p>X coordinates</p> required <code>y</code> <code>array - like</code> <p>Y coordinates</p> required <code>n</code> <code>int</code> <p>Number of bins to divide grid. Default is 200. Higher values give more detail but are slower.</p> <code>200</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A vector of densities for plotting</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create sample data with varying density\n&gt;&gt;&gt; x = np.concatenate([\n...     np.random.normal(0, 0.1, 10000),\n...     np.random.normal(0, 0.1, 1000)\n... ])\n&gt;&gt;&gt; y = np.concatenate([\n...     np.random.normal(0, 0.1, 10000),\n...     np.random.normal(0.1, 0.2, 1000)\n... ])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute density for each point\n&gt;&gt;&gt; density = buencolors.get_density(x, y)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot with color mapped to density\n&gt;&gt;&gt; plt.scatter(x, y, c=density, cmap='viridis', s=1)\n&gt;&gt;&gt; plt.colorbar(label='Point Density')\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use with a BuenColors palette\n&gt;&gt;&gt; density = buencolors.get_density(x, y, n=300)  # Higher resolution\n&gt;&gt;&gt; plt.scatter(x, y, c=density, cmap='solar_flare', s=1, alpha=0.5)\n&gt;&gt;&gt; plt.colorbar()\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"reference/buencolors/#buencolors.shuffle","title":"<code>shuffle(x)</code>","text":"<pre><code>shuffle(x: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre><pre><code>shuffle(x: pd.Series) -&gt; pd.Series\n</code></pre><pre><code>shuffle(x: np.ndarray) -&gt; np.ndarray\n</code></pre><pre><code>shuffle(x: ArrayLike) -&gt; list\n</code></pre><pre><code>shuffle(x: list) -&gt; list\n</code></pre><pre><code>shuffle(x: tuple) -&gt; tuple\n</code></pre><pre><code>shuffle(x: anndata.AnnData) -&gt; anndata.AnnData\n</code></pre> <p>Shuffle the order of rows/elements to make plots independent of point ordering.</p> <p>This function accepts various data types and returns a shuffled version while preserving the original type when possible. Useful for preventing visual artifacts caused by data ordering in scatter plots.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array-like, DataFrame, or Series</code> <p>Data to shuffle. Can be a list, tuple, numpy array, pandas DataFrame, or pandas Series.</p> required <p>Returns:</p> Type Description <code>same type as input</code> <p>Shuffled version of the input data. For DataFrames and Series, the index is reset. For numpy arrays, a shuffled copy is returned. For lists, a shuffled list is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Shuffle a DataFrame for plotting\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'x': np.random.randn(1000),\n...     'y': np.random.randn(1000),\n...     'category': np.random.choice(['A', 'B', 'C'], 1000)\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Without shuffling, later categories may cover earlier ones\n&gt;&gt;&gt; df_shuffled = buencolors.shuffle(df)\n&gt;&gt;&gt; colors = {'A': 'red', 'B': 'blue', 'C': 'green'}\n&gt;&gt;&gt; df_shuffled['color'] = df_shuffled['category'].map(colors)\n&gt;&gt;&gt; plt.scatter(df_shuffled['x'], df_shuffled['y'], c=df_shuffled['color'], alpha=0.5)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Shuffle a numpy array\n&gt;&gt;&gt; arr = np.random.randn(100, 2)\n&gt;&gt;&gt; arr_shuffled = buencolors.shuffle(arr)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Shuffle a list\n&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; lst_shuffled = buencolors.shuffle(lst)\n</code></pre> Notes <p>This also supports scanpy AnnData objects by shuffling the obs index when the anndata package is installed.</p>"},{"location":"reference/buencolors/#buencolors.number_to_color","title":"<code>number_to_color(values, palette, value_range=None, n_bins=None, return_rgb=False)</code>","text":"<p>Map numeric values to colors from a palette.</p> <p>This is the pythonic equivalent of R's numberToColorVec function, with support for both continuous and discrete (binned) color mapping.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>array - like</code> <p>Numeric values to map to colors</p> required <code>palette</code> <code>str or Colormap</code> <p>Name of a registered colormap or a Colormap object. Can be any matplotlib colormap or a BuenColors palette name.</p> required <code>value_range</code> <code>tuple[float, float]</code> <p>(min, max) values to clip and normalize. If None, uses the min/max of values. Values outside this range will be clipped to the range bounds.</p> <code>None</code> <code>n_bins</code> <code>int</code> <p>Number of discrete color bins to use. If None (default), uses continuous mapping. If specified, values will be binned into n_bins discrete colors, similar to the R implementation (which uses 100 bins). Common values: 100, 256.</p> <code>None</code> <code>return_rgb</code> <code>bool</code> <p>If True, return RGB arrays instead of hex strings. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str] or ndarray</code> <p>If return_rgb is False: list of hex color strings (e.g., '#FF5733') If return_rgb is True: numpy array of shape (n, 4) with RGBA values in [0, 1]</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Basic usage: map values to colors\n&gt;&gt;&gt; values = np.random.randn(1000) ** 2\n&gt;&gt;&gt; colors = buencolors.number_to_color(values, \"viridis\")\n&gt;&gt;&gt; plt.scatter(np.arange(len(values)), values, c=colors)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use a BuenColors palette\n&gt;&gt;&gt; colors = buencolors.number_to_color(values, \"solar_flare\")\n&gt;&gt;&gt; plt.scatter(np.arange(len(values)), values, c=colors)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Discrete binned colors (like R implementation)\n&gt;&gt;&gt; colors = buencolors.number_to_color(values, \"brewer_spectra\", n_bins=100)\n&gt;&gt;&gt; plt.scatter(np.arange(len(values)), values, c=colors, s=20)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With custom value range (capping)\n&gt;&gt;&gt; colors = buencolors.number_to_color(values, \"plasma\", value_range=(0, 2))\n&gt;&gt;&gt; plt.scatter(np.arange(len(values)), values, c=colors)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get RGB arrays instead of hex\n&gt;&gt;&gt; colors_rgb = buencolors.number_to_color(values[:10], \"magma\", return_rgb=True)\n&gt;&gt;&gt; print(colors_rgb.shape)  # (10, 4) RGBA values\n(10, 4)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Combined with shuffle for better visualization\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'x': np.random.randn(500),\n...     'y': np.random.randn(500),\n...     'value': np.random.randn(500) ** 2\n... })\n&gt;&gt;&gt; df['color'] = buencolors.number_to_color(df['value'], \"flame_flame\", n_bins=50)\n&gt;&gt;&gt; df = buencolors.shuffle(df)\n&gt;&gt;&gt; plt.scatter(df['x'], df['y'], c=df['color'], s=30, alpha=0.6)\n&gt;&gt;&gt; plt.show()\n</code></pre> Notes <p>The default behavior (n_bins=None) uses continuous color mapping for smoother gradients. Set n_bins=100 to match the R implementation's discrete binning.</p> <p>For more advanced discrete colormapping, consider using matplotlib's BoundaryNorm.</p>"},{"location":"reference/buencolors/#buencolors.clean_umap","title":"<code>clean_umap(adata, color, ax=None, axis_len=0.2, thickness=3.0, **kwargs)</code>","text":"<p>Plot a clean UMAP with minimal decorations and custom axis indicators.</p> <p>Plots a Scanpy UMAP with no borders/ticks, but adds a small 'L' shaped axis indicator in the bottom left corner with arrowheads. The legend is ejected to the right side of the plot. Cells are automatically shuffled to avoid non-random ordering artifacts.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>AnnData object containing the UMAP coordinates</p> required <code>color</code> <code>str</code> <p>Column in adata.obs or gene name to color cells by</p> required <code>ax</code> <code>Axes</code> <p>Existing matplotlib axis. If None, creates a new axis.</p> <code>None</code> <code>axis_len</code> <code>float</code> <p>Length of the custom axis arrows in relative axes coordinates (0-1). Default is 0.2.</p> <code>0.2</code> <code>thickness</code> <code>float</code> <p>Line width of the custom axes. Default is 3.0.</p> <code>3.0</code> <code>**kwargs</code> <p>Additional keyword arguments passed to sc.pl.umap</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib axes containing the UMAP plot</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import scanpy as sc\n&gt;&gt;&gt; import buencolors\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load example dataset\n&gt;&gt;&gt; adata = sc.datasets.pbmc3k_processed()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot clean UMAP colored by cell type\n&gt;&gt;&gt; buencolors.clean_umap(adata, color='louvain')\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Customize axis length and thickness\n&gt;&gt;&gt; buencolors.clean_umap(adata, color='louvain', axis_len=0.3, thickness=4.0)\n&gt;&gt;&gt; plt.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use with existing axis and pass additional arguments\n&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 6))\n&gt;&gt;&gt; buencolors.clean_umap(adata, color='CST3', ax=ax, cmap='viridis')\n&gt;&gt;&gt; plt.tight_layout()\n&gt;&gt;&gt; plt.show()\n</code></pre>"}]}